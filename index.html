<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content">
    <title>Playground of Parallel</title>
    
    <link rel="icon" href="data:;base64,iVBORw0KGgo="> 
    
    <meta property="og:type" content="website">
    <meta property="og:title" content="Playground of Parallel">
    <meta property="og:description" content="TILT YOUR WORLD.">

    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');

        /* 2. ì „ì²´ ë ˆì´ì•„ì›ƒ ì´ˆê¸°í™” */
        html, body {
            width: 100%; height: 100%; margin: 0; padding: 0;
            overflow: hidden; position: fixed; top: 0; left: 0;
            background-color: #E0E0E0; /* ì í™” ì „ ìƒ‰ìƒ */
            color: #111; font-family: 'Pretendard', sans-serif;
            touch-action: none; -webkit-user-select: none; user-select: none;
            transition: background-color 1.5s ease; /* í…Œë§ˆ ë³€ê²½ ì‹œ ë¶€ë“œëŸ½ê²Œ */
        }
        
        body.active { background-color: #F9F9F9; }

        /* UI ë ˆì´ì–´ */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10; padding: 24px;
            box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        header h1 { font-size: 2rem; font-weight: 800; letter-spacing: -0.05em; line-height: 1.1; mix-blend-mode: exclusion; margin: 0; }
        header p { font-size: 0.9rem; margin-top: 8px; font-weight: 500; opacity: 0.6; mix-blend-mode: exclusion; }
        .status-bar { display: flex; gap: 12px; font-size: 0.8rem; font-weight: 600; mix-blend-mode: exclusion; }
        .tag { background: #111; color: #fff; padding: 4px 12px; border-radius: 100px; text-transform: uppercase; }
        
        footer { text-align: right; pointer-events: none; }
        footer .sub-text { font-size: 1rem; margin-top: 10px; font-weight: 400; mix-blend-mode: exclusion; }

        /* 3. íƒ€ì´í¬ê·¸ë˜í”¼ ì• ë‹ˆë©”ì´ì…˜ */
        .big-text-container {
            display: flex; flex-direction: column; align-items: flex-end;
            font-size: 3.5rem; font-weight: 900; line-height: 0.9;
            letter-spacing: -0.08em; color: #111; mix-blend-mode: exclusion;
        }
        
        @media (max-width: 768px) {
            .big-text-container { font-size: 2.5rem; }
            header h1 { font-size: 1.5rem; }
        }

        .title-row { display: flex; overflow: hidden; }

        .tilt-word {
            display: inline-block; opacity: 0;
            transform: translateX(100%);
            transition: all 0.8s cubic-bezier(0.25, 1, 0.5, 1);
        }
        
        body.active .tilt-word {
            opacity: 1; transform: translateX(0); 
            margin-right: 0; /* ì •ë ¬ ìˆ˜ì •ì„ ìœ„í•´ ë§ˆì§„ ì œê±° */
        }

        #world { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; outline: none; }
        
        .hint {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #666; font-size: 0.9rem; pointer-events: none; text-align: center;
            opacity: 1; transition: opacity 0.5s; mix-blend-mode: exclusion;
            font-weight: 600; letter-spacing: 0.05em;
        }
        body.active .hint { opacity: 0; }

        /* --- âœ¨ Dream UI --- */
        .dream-controls {
            position: absolute; bottom: 24px; left: 24px;
            pointer-events: auto; display: flex; gap: 10px; align-items: center;
            opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }
        body.active .dream-controls { opacity: 1; pointer-events: auto; }

        .dream-btn {
            background: #111; color: #fff; border: none; padding: 10px 18px;
            border-radius: 100px; font-family: 'Pretendard'; font-weight: 700;
            cursor: pointer; font-size: 0.9rem; transition: transform 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1); display: flex; align-items: center; gap: 6px;
        }
        .dream-btn:active { transform: scale(0.95); }
        .dream-btn:disabled { opacity: 0.5; cursor: wait; }

        .dream-input-container {
            display: flex; gap: 8px; background: rgba(255,255,255,0.9);
            padding: 6px; border-radius: 100px; transform: translateX(-20px);
            opacity: 0; visibility: hidden; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .dream-input-container.open {
            transform: translateX(0); opacity: 1; visibility: visible;
        }
        .dream-input {
            border: none; background: transparent; outline: none;
            padding: 4px 12px; font-family: 'Pretendard'; font-size: 0.9rem; width: 140px;
        }

    </style>
</head>

<body>

    <canvas id="world"></canvas>

    <div class="hint">PULL TO IGNITE<br>â†—</div>

    <div class="ui-layer">
        <header>
            <div class="status-bar"><span class="tag">ì´í‰í–‰íŒ¨ëŸ¬ë </span></div><br>
            <h1>PLAYFUL<br>REFRESHING<br>LITERAL</h1>
            <p>Creator / Musician / Designer</p>
        </header>

        <!-- âœ¨ Gemini Dream Controls -->
        <div class="dream-controls">
            <button id="dream-toggle" class="dream-btn">âœ¨ Dream</button>
            <div class="dream-input-container" id="dream-container">
                <input type="text" id="dream-input" class="dream-input" placeholder="e.g. Cyberpunk, Candy..." autocomplete="off">
                <button id="dream-submit" class="dream-btn" style="padding: 8px 14px;">Go</button>
            </div>
        </div>

        <footer>
            <!-- 3ë‹¨ êµ¬ì„±ìœ¼ë¡œ ë³€ê²½: TILT / YOUR / WORLD -->
            <div class="big-text-container">
                <div class="title-row">
                    <span class="tilt-word">TILT</span>
                </div>
                <div>YOUR</div>
                <div>WORLD.</div>
            </div>
            <div class="sub-text">Do What You Wanna Do.</div>
        </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        // --- Gemini Configuration ---
        const apiKey = ""; // Will be injected by runtime
        
        async function callGemini(prompt, isJson = false) {
            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                
                const payload = {
                    contents: [{ parts: [{ text: prompt }] }]
                };

                if (isJson) {
                    payload.generationConfig = { responseMimeType: "application/json" };
                }

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) throw new Error("Gemini API Error");
                const data = await response.json();
                return data.candidates[0].content.parts[0].text;
            } catch (error) {
                console.error("Gemini Error:", error);
                return null;
            }
        }

        // --- Physics Engine Setup ---
        const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner,
              Bodies = Matter.Bodies, Composite = Matter.Composite, Mouse = Matter.Mouse,
              MouseConstraint = Matter.MouseConstraint, Events = Matter.Events, Body = Matter.Body;

        const engine = Engine.create();
        const world = engine.world;
        const canvas = document.getElementById('world');
        const render = Render.create({
            element: document.body, canvas: canvas, engine: engine,
            options: { width: window.innerWidth, height: window.innerHeight, background: 'transparent', wireframes: false, showAngleIndicator: false, pixelRatio: 1 }
        });

        // --- Dynamic World Settings ---
        // ê¸°ë³¸ í…Œë§ˆ(í‰í–‰ ë‹˜ì˜ ìƒ‰ìƒ) ì €ì¥
        const defaultTheme = {
            colors: ['#FFD200', '#2ED573', '#00CCFF', '#FF3F6C'],
            frictionAir: 0.005,
            restitution: 0.9,
            backgroundColor: '#F9F9F9',
            gravityY: 1
        };

        // í˜„ì¬ í…Œë§ˆ (ì´ˆê¸°ê°’ì€ ê¸°ë³¸ í…Œë§ˆ)
        let currentTheme = { ...defaultTheme };

        // 2. Walls
        let walls = [];
        function createWalls() {
            const w = window.innerWidth, h = window.innerHeight, t = 1000;
            const opt = { isStatic: true, render: { fillStyle: 'transparent' }, restitution: 1.0 };
            Composite.remove(world, walls);
            walls = [ Bodies.rectangle(w/2, -t/2, w+t, t, opt), Bodies.rectangle(w/2, h+t/2, w+t, t, opt), Bodies.rectangle(w+t/2, h/2, t, h+t, opt), Bodies.rectangle(-t/2, h/2, t, h+t, opt) ];
            Composite.add(world, walls);
        }
        createWalls();

        // 3. Shape Factory
        function createShape(x, y) {
            const size = 30 + Math.random() * 50;
            const color = currentTheme.colors[Math.floor(Math.random() * currentTheme.colors.length)];
            const type = Math.random();
            
            // Apply theme physics
            const opt = { 
                render: { fillStyle: color }, 
                restitution: currentTheme.restitution, 
                friction: 0.001, 
                frictionAir: currentTheme.frictionAir, 
                density: 0.005 
            };
            
            let body;
            if (type < 0.33) {
                body = Bodies.circle(x, y, size/2, opt);
                body.label = "Circle";
            } else if (type < 0.66) {
                body = Bodies.rectangle(x, y, size, size, { ...opt, chamfer: { radius: 10 } });
                body.label = "Square";
            } else {
                body = Bodies.polygon(x, y, 3, size/1.5, { ...opt, chamfer: { radius: 5 } });
                body.label = "Triangle";
            }
            return body;
        }

        function spawnInitialShapes() {
            for (let i = 0; i < 20; i++) {
                Composite.add(world, createShape(Math.random() * window.innerWidth, -Math.random() * 500 - 50));
            }
        }

        // 4. Switch Mechanism (Updated for better visuals & constraints)
        let switchAnchor, switchVisualKnob, switchHitKnob;
        let isWorldActive = false; 

        function createPullSwitch() {
            // Anchor Yë¥¼ í™”ë©´ ìœ„ìª½ ë°”ê¹¥(-50)ìœ¼ë¡œ ì´ë™í•˜ì—¬ ì‹œì‘ì ì´ ë³´ì´ì§€ ì•Šê²Œ í•¨
            const x = window.innerWidth - 60; 
            const y = -50; 
            const length = 170; // ì•µì»¤ê°€ ì˜¬ë¼ê°„ ë§Œí¼ ì¤„ ê¸¸ì´ ì¡°ì •

            switchAnchor = Bodies.circle(x, y, 10, { isStatic: true, render: { visible: false } });
            
            switchVisualKnob = Bodies.circle(x, y + length, 4, { density: 0.0001, frictionAir: 0.05, render: { fillStyle: '#333' }, collisionFilter: { mask: 0 } });
            switchHitKnob = Bodies.circle(x, y + length, 40, { density: 0.0001, frictionAir: 0.05, render: { visible: false } });
            
            // Limit Constraint: stiffnessë¥¼ ë†’ì—¬ì„œ(0.9) ì¼ì • ì´ìƒ íŒ½íŒ½í•´ì§€ì§€ ì•Šê²Œ ì œí•œ
            const stringLimit = Matter.Constraint.create({ 
                bodyA: switchAnchor, 
                bodyB: switchVisualKnob, 
                stiffness: 0.9, 
                length: length * 1.3, // ìµœëŒ€ ëŠ˜ì–´ë‚˜ëŠ” ê¸¸ì´ ì œí•œ
                render: { visible: false } 
            });
            
            const stringSpring = Matter.Constraint.create({ 
                bodyA: switchAnchor, 
                bodyB: switchVisualKnob, 
                stiffness: 0.05, 
                length: length, 
                damping: 0.1, 
                render: { visible: true, lineWidth: 1.5, strokeStyle: '#333' } 
            });
            
            const glue = Matter.Constraint.create({ bodyA: switchVisualKnob, bodyB: switchHitKnob, stiffness: 1, length: 0, render: { visible: false } });
            
            Composite.add(world, [switchAnchor, switchVisualKnob, switchHitKnob, stringLimit, stringSpring, glue]);
            return switchHitKnob;
        }
        const switchKnob = createPullSwitch();

        // 5. Mouse/Touch & Interaction
        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse, constraint: { stiffness: 0.2, render: { visible: false } }
        });
        Composite.add(world, mouseConstraint);

        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        // 6. Resize Handler
        window.addEventListener('resize', () => {
            render.canvas.width = window.innerWidth; render.canvas.height = window.innerHeight;
            render.options.width = window.innerWidth; render.options.height = window.innerHeight;
            createWalls();
            if (switchAnchor) {
                const newX = window.innerWidth - 60;
                Body.setPosition(switchAnchor, { x: newX, y: -50 });
                Body.setPosition(switchVisualKnob, { x: newX, y: 100 });
                Body.setPosition(switchHitKnob, { x: newX, y: 100 });
                Body.setVelocity(switchVisualKnob, { x: 0, y: 0 });
                Body.setVelocity(switchHitKnob, { x: 0, y: 0 });
            }
        });

        document.body.addEventListener('touchstart', (e)=>e.preventDefault(), {passive: false});
        document.body.addEventListener('touchmove', (e)=>e.preventDefault(), {passive: false});

        // ==========================================
        // ğŸ”¥ LOGIC & AI FEATURES
        // ==========================================
        
        // 1. Click Handling: Spawn Only
        Events.on(mouseConstraint, 'mousedown', async function (event) {
            if (!isWorldActive) return;
            if (event.body === switchHitKnob) return;

            // Only spawn if clicked on empty space
            if (!mouseConstraint.body) {
                Composite.add(world, createShape(event.mouse.position.x, event.mouse.position.y));
            }
        });

        // --- Feature: Dream a World (Theme Generator) ---
        const dreamToggle = document.getElementById('dream-toggle');
        const dreamContainer = document.getElementById('dream-container');
        const dreamInput = document.getElementById('dream-input');
        const dreamSubmit = document.getElementById('dream-submit');

        dreamToggle.addEventListener('click', () => {
            dreamContainer.classList.toggle('open');
            if (dreamContainer.classList.contains('open')) dreamInput.focus();
        });

        dreamSubmit.addEventListener('click', async () => {
            const concept = dreamInput.value.trim();
            if (!concept) return;

            dreamSubmit.textContent = "âœ¨...";
            dreamSubmit.disabled = true;

            const prompt = `You are a physics engine designer. Generate a JSON theme for a Matter.js world based on the concept: "${concept}".
            JSON Schema:
            {
              "colors": ["#hex", "#hex", "#hex", "#hex"],
              "backgroundColor": "#hex",
              "gravityY": number (0.5 for floaty/space, 2.0 for heavy, default 1),
              "restitution": number (0.1 for dull to 1.3 for super bouncy),
              "frictionAir": number (0.001 to 0.1 for thick atmosphere/water)
            }
            Do not use markdown formatting. Just raw JSON.`;

            try {
                const jsonStr = await callGemini(prompt, true);
                if (jsonStr) {
                    const theme = JSON.parse(jsonStr);
                    applyTheme(theme);
                }
            } catch(e) {
                console.error("Theme parsing failed", e);
                alert("The dream was too abstract. Try again!");
            }

            dreamSubmit.textContent = "Go";
            dreamSubmit.disabled = false;
            dreamContainer.classList.remove('open');
        });

        function applyTheme(theme) {
            // Update State
            currentTheme.colors = theme.colors;
            currentTheme.restitution = theme.restitution;
            currentTheme.frictionAir = theme.frictionAir;

            // Apply Global Styles
            document.body.style.backgroundColor = theme.backgroundColor || "#F9F9F9";
            
            // Apply Physics Globals
            if (theme.gravityY !== undefined) engine.world.gravity.scale = 0.001 * theme.gravityY;

            // Respawn Shapes with new theme
            const bodies = Composite.allBodies(world);
            bodies.forEach(b => {
                if (!b.isStatic && b !== switchAnchor && b !== switchVisualKnob && b !== switchHitKnob) {
                    Composite.remove(world, b);
                }
            });
            spawnInitialShapes();
        }

        // --- Standard App Logic ---

        let isPulled = false;
        Events.on(engine, 'beforeUpdate', function() {
            // ìŠ¤ìœ„ì¹˜ê°€ ì¼ì • ì´ìƒ ë‚´ë ¤ì˜¤ë©´ ë‹¹ê²¨ì§„ ê²ƒìœ¼ë¡œ ê°„ì£¼
            if (switchHitKnob.position.y > 220) isPulled = true;
        });

        Events.on(mouseConstraint, 'enddrag', function(event) {
            if (event.body === switchHitKnob && isPulled) {
                if (!isWorldActive) {
                    // 1. ì²˜ìŒ ë‹¹ê²¼ì„ ë•Œ: ì í™” (Ignite)
                    igniteWorld();
                } else {
                    // 2. ì´ë¯¸ ì¼œì ¸ ìˆì„ ë•Œ ë‹¹ê¸°ë©´: í…Œë§ˆ ë¦¬ì…‹ (ì›ë˜ ì„¸ê³„ë¡œ ë³µê·€)
                    applyTheme(defaultTheme);
                    if (navigator.vibrate) navigator.vibrate(30);
                }
                isPulled = false;
            }
        });

        function igniteWorld() {
            isWorldActive = true; 
            document.body.classList.add('active');
            spawnInitialShapes();
            if (navigator.vibrate) navigator.vibrate([50, 100, 50]);
            
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission().then(s => {
                    if (s === 'granted') enableTilt();
                }).catch(e => console.log(e));
            } else {
                enableTilt();
            }
        }

        function enableTilt() {
            window.addEventListener('deviceorientation', (e) => {
                if (e.gamma !== null) {
                    engine.world.gravity.x = Math.min(Math.max(e.gamma / 20, -1), 1);
                    engine.world.gravity.y = Math.min(Math.max(e.beta / 20, -1), 1);
                }
            });
        }

        Events.on(engine, 'collisionStart', function(event) {
            if (!isWorldActive) return; 
            event.pairs.forEach(pair => {
                if ((pair.bodyA.speed + pair.bodyB.speed) > 15 && navigator.vibrate) navigator.vibrate(5);
            });
        });

    </script>
</body>
</html>
